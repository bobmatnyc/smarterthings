#!/usr/bin/env node
/**
 * Interactive configuration menu for mcp-smarterthings.
 *
 * Provides a user-friendly CLI for managing:
 * - SmartThings Personal Access Token (PAT)
 * - OpenRouter API Key
 * - Other environment variables
 *
 * Features:
 * - Interactive prompts with validation
 * - Token testing/verification
 * - Secure .env.local file management
 * - Status display with masked credentials
 *
 * Usage:
 *   pnpm config           # Start interactive menu
 *   pnpm config:dev       # Development mode with tsx
 */

import { createInterface } from 'readline/promises';
import { readFileSync, writeFileSync, existsSync } from 'fs';
import { resolve } from 'path';
import chalk from 'chalk';
import { SmartThingsClient, BearerTokenAuthenticator } from '@smartthings/core-sdk';

/**
 * Environment variable configuration.
 */
interface EnvConfig {
  SMARTTHINGS_PAT?: string;
  SMARTTHINGS_TOKEN?: string;
  OPENROUTER_API_KEY?: string;
  [key: string]: string | undefined;
}

/**
 * Configuration manager for .env.local file.
 */
class ConfigManager {
  private readonly envPath: string;
  private config: EnvConfig = {};

  constructor() {
    this.envPath = resolve(process.cwd(), '.env.local');
    this.loadConfig();
  }

  /**
   * Load configuration from .env.local file.
   */
  private loadConfig(): void {
    if (!existsSync(this.envPath)) {
      console.log(chalk.yellow('‚ö†Ô∏è  No .env.local file found. Creating new one...'));
      this.config = {};
      return;
    }

    try {
      const content = readFileSync(this.envPath, 'utf-8');
      const lines = content.split('\n');

      for (const line of lines) {
        const trimmed = line.trim();
        if (trimmed && !trimmed.startsWith('#')) {
          const [key, ...valueParts] = trimmed.split('=');
          if (key && valueParts.length > 0) {
            this.config[key.trim()] = valueParts.join('=').trim();
          }
        }
      }
    } catch (error) {
      console.error(chalk.red('Error reading .env.local:'), error);
      this.config = {};
    }
  }

  /**
   * Save configuration to .env.local file.
   */
  private saveConfig(): void {
    try {
      const lines = Object.entries(this.config)
        .filter(([_, value]) => value !== undefined && value !== '')
        .map(([key, value]) => `${key}=${value}`);

      const content = [
        '# mcp-smarterthings configuration',
        '# Generated by config menu',
        '',
        ...lines,
        '',
      ].join('\n');

      writeFileSync(this.envPath, content, 'utf-8');
      console.log(chalk.green('‚úÖ Configuration saved to .env.local'));
    } catch (error) {
      console.error(chalk.red('Error saving .env.local:'), error);
      throw error;
    }
  }

  /**
   * Get a configuration value.
   */
  get(key: string): string | undefined {
    return this.config[key];
  }

  /**
   * Set a configuration value.
   */
  set(key: string, value: string): void {
    this.config[key] = value;
  }

  /**
   * Delete a configuration value.
   */
  delete(key: string): void {
    delete this.config[key];
  }

  /**
   * Save changes to file.
   */
  save(): void {
    this.saveConfig();
  }

  /**
   * Get all configuration keys.
   */
  keys(): string[] {
    return Object.keys(this.config);
  }

  /**
   * Mask a value for display (show first/last 4 chars).
   */
  static maskValue(value: string): string {
    if (!value || value.length < 12) {
      return '***';
    }
    return `${value.substring(0, 4)}...${value.substring(value.length - 4)}`;
  }
}

/**
 * Test SmartThings PAT token validity.
 */
async function testSmartThingsPAT(token: string): Promise<boolean> {
  try {
    const client = new SmartThingsClient(new BearerTokenAuthenticator(token));
    const locations = await client.locations.list();

    console.log(chalk.green('‚úÖ Token is valid!'));
    console.log(chalk.blue(`   Found ${locations.length} location(s)`));

    if (locations.length > 0) {
      console.log(chalk.gray('   Locations:'));
      locations.forEach((loc) => {
        console.log(chalk.gray(`   - ${loc.name}`));
      });
    }

    return true;
  } catch (error) {
    console.log(chalk.red('‚ùå Token is invalid or expired'));
    if (error instanceof Error) {
      console.log(chalk.gray(`   Error: ${error.message}`));
    }
    return false;
  }
}

/**
 * Interactive configuration menu.
 */
class ConfigMenu {
  private readonly rl;
  private readonly config: ConfigManager;

  constructor() {
    this.rl = createInterface({
      input: process.stdin,
      output: process.stdout,
    });
    this.config = new ConfigManager();
  }

  /**
   * Display main menu.
   */
  private displayMenu(): void {
    console.log('\n' + chalk.bold.cyan('‚îÅ'.repeat(60)));
    console.log(chalk.bold.cyan('  üè† SmartThings MCP Server - Configuration Menu'));
    console.log(chalk.bold.cyan('‚îÅ'.repeat(60)));
    console.log();
    console.log(chalk.white('  1. ') + chalk.green('Configure SmartThings PAT'));
    console.log(chalk.white('  2. ') + chalk.green('Configure OpenRouter API Key'));
    console.log(chalk.white('  3. ') + chalk.blue('Test SmartThings Connection'));
    console.log(chalk.white('  4. ') + chalk.yellow('View Current Configuration'));
    console.log(chalk.white('  5. ') + chalk.red('Clear All Configuration'));
    console.log(chalk.white('  0. ') + chalk.gray('Exit'));
    console.log();
    console.log(chalk.bold.cyan('‚îÅ'.repeat(60)));
  }

  /**
   * Display current configuration status.
   */
  private displayStatus(): void {
    console.log('\n' + chalk.bold('üìã Current Configuration:'));
    console.log(chalk.gray('‚îÄ'.repeat(60)));

    const smartthingsPAT = this.config.get('SMARTTHINGS_PAT');
    const openrouterKey = this.config.get('OPENROUTER_API_KEY');

    console.log(
      chalk.white('SmartThings PAT:     '),
      smartthingsPAT
        ? chalk.green(ConfigManager.maskValue(smartthingsPAT))
        : chalk.red('Not configured')
    );

    console.log(
      chalk.white('OpenRouter API Key:  '),
      openrouterKey
        ? chalk.green(ConfigManager.maskValue(openrouterKey))
        : chalk.red('Not configured')
    );

    console.log(chalk.gray('‚îÄ'.repeat(60)));
  }

  /**
   * Configure SmartThings PAT.
   */
  private async configureSmartThingsPAT(): Promise<void> {
    console.log('\n' + chalk.bold.blue('üîß Configure SmartThings Personal Access Token'));
    console.log(chalk.gray('‚îÄ'.repeat(60)));
    console.log();
    console.log(chalk.white('To create a PAT:'));
    console.log(chalk.gray('  1. Visit: https://account.smartthings.com/tokens'));
    console.log(chalk.gray('  2. Click "Generate new token"'));
    console.log(chalk.gray('  3. Give it a name (e.g., "MCP Server")'));
    console.log(chalk.gray('  4. Select scopes: devices, locations, scenes'));
    console.log(chalk.gray('  5. Copy the token (you won\'t see it again!)'));
    console.log();

    const current = this.config.get('SMARTTHINGS_PAT');
    if (current) {
      console.log(
        chalk.yellow('Current PAT: ') + chalk.gray(ConfigManager.maskValue(current))
      );
    }

    const token = await this.rl.question(
      chalk.white('Enter your SmartThings PAT (or press Enter to cancel): ')
    );

    if (!token.trim()) {
      console.log(chalk.yellow('‚ö†Ô∏è  Cancelled'));
      return;
    }

    // Validate token format
    if (token.length < 20) {
      console.log(chalk.red('‚ùå Token appears too short. Please check and try again.'));
      return;
    }

    console.log(chalk.blue('\nüîç Testing token...'));
    const isValid = await testSmartThingsPAT(token);

    if (!isValid) {
      const proceed = await this.rl.question(
        chalk.yellow('\nToken test failed. Save anyway? (y/N): ')
      );
      if (proceed.toLowerCase() !== 'y') {
        console.log(chalk.yellow('‚ö†Ô∏è  Cancelled'));
        return;
      }
    }

    this.config.set('SMARTTHINGS_PAT', token);
    this.config.set('SMARTTHINGS_TOKEN', token); // Keep both for compatibility
    this.config.save();
  }

  /**
   * Configure OpenRouter API Key.
   */
  private async configureOpenRouterKey(): Promise<void> {
    console.log('\n' + chalk.bold.blue('üîß Configure OpenRouter API Key'));
    console.log(chalk.gray('‚îÄ'.repeat(60)));
    console.log();
    console.log(chalk.white('To get an API key:'));
    console.log(chalk.gray('  1. Visit: https://openrouter.ai/keys'));
    console.log(chalk.gray('  2. Sign in or create an account'));
    console.log(chalk.gray('  3. Click "Create Key"'));
    console.log(chalk.gray('  4. Copy the API key'));
    console.log();

    const current = this.config.get('OPENROUTER_API_KEY');
    if (current) {
      console.log(
        chalk.yellow('Current Key: ') + chalk.gray(ConfigManager.maskValue(current))
      );
    }

    const apiKey = await this.rl.question(
      chalk.white('Enter your OpenRouter API Key (or press Enter to cancel): ')
    );

    if (!apiKey.trim()) {
      console.log(chalk.yellow('‚ö†Ô∏è  Cancelled'));
      return;
    }

    // Validate key format
    if (apiKey.length < 20) {
      console.log(chalk.red('‚ùå Key appears too short. Please check and try again.'));
      return;
    }

    this.config.set('OPENROUTER_API_KEY', apiKey);
    this.config.save();
  }

  /**
   * Test SmartThings connection.
   */
  private async testConnection(): Promise<void> {
    console.log('\n' + chalk.bold.blue('üîç Testing SmartThings Connection'));
    console.log(chalk.gray('‚îÄ'.repeat(60)));

    const token = this.config.get('SMARTTHINGS_PAT');

    if (!token) {
      console.log(chalk.red('‚ùå No SmartThings PAT configured'));
      console.log(chalk.yellow('   Please configure a PAT first (option 1)'));
      return;
    }

    console.log(chalk.blue('Testing connection...'));
    await testSmartThingsPAT(token);
  }

  /**
   * Clear all configuration.
   */
  private async clearConfiguration(): Promise<void> {
    console.log('\n' + chalk.bold.red('‚ö†Ô∏è  Clear All Configuration'));
    console.log(chalk.gray('‚îÄ'.repeat(60)));

    const confirm = await this.rl.question(
      chalk.yellow('Are you sure? This will delete all stored credentials. (y/N): ')
    );

    if (confirm.toLowerCase() !== 'y') {
      console.log(chalk.yellow('‚ö†Ô∏è  Cancelled'));
      return;
    }

    this.config.keys().forEach((key) => this.config.delete(key));
    this.config.save();
    console.log(chalk.green('‚úÖ All configuration cleared'));
  }

  /**
   * Run the interactive menu.
   */
  async run(): Promise<void> {
    console.clear();

    while (true) {
      this.displayMenu();
      this.displayStatus();

      const choice = await this.rl.question(
        chalk.white('\nüëâ Select an option: ')
      );

      switch (choice.trim()) {
        case '1':
          await this.configureSmartThingsPAT();
          break;
        case '2':
          await this.configureOpenRouterKey();
          break;
        case '3':
          await this.testConnection();
          await this.rl.question(chalk.gray('\nPress Enter to continue...'));
          break;
        case '4':
          this.displayStatus();
          await this.rl.question(chalk.gray('\nPress Enter to continue...'));
          break;
        case '5':
          await this.clearConfiguration();
          break;
        case '0':
          console.log(chalk.green('\n‚ú® Configuration complete!'));
          console.log(chalk.blue('   Run "pnpm chat:dev" to start the chat interface'));
          console.log();
          this.rl.close();
          return;
        default:
          console.log(chalk.red('\n‚ùå Invalid option. Please try again.'));
          await this.rl.question(chalk.gray('Press Enter to continue...'));
      }

      console.clear();
    }
  }
}

/**
 * Main entry point.
 */
async function main(): Promise<void> {
  try {
    const menu = new ConfigMenu();
    await menu.run();
  } catch (error) {
    console.error(chalk.red('\n‚ùå Error:'), error);
    process.exit(1);
  }
}

// Run if executed directly
if (import.meta.url === `file://${process.argv[1]}`) {
  main();
}
