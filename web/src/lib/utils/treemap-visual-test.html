<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Treemap Visual Test</title>
	<style>
		body {
			font-family: Arial, sans-serif;
			margin: 0;
			padding: 20px;
			background: #f5f5f5;
		}
		.container {
			max-width: 1200px;
			margin: 0 auto;
		}
		h1 {
			text-align: center;
			color: #333;
		}
		.treemap-container {
			position: relative;
			width: 100%;
			height: 600px;
			background: #000;
			border: 3px solid #000;
			margin: 20px 0;
		}
		.rect {
			position: absolute;
			cursor: pointer;
			transition: all 0.2s ease;
			display: flex;
			flex-direction: column;
			padding: 10px;
		}
		.rect:hover {
			transform: scale(1.02);
			box-shadow: 0 8px 16px rgba(0, 0, 0, 0.3);
			z-index: 10;
		}
		.rect-label {
			font-weight: bold;
			font-size: 14px;
			text-transform: uppercase;
			letter-spacing: 0.05em;
			margin-bottom: 5px;
		}
		.rect-value {
			font-size: 12px;
			color: #666;
		}
	</style>
</head>
<body>
	<div class="container">
		<h1>Squarified Treemap Visual Test</h1>
		<div class="treemap-container" id="treemap"></div>
		<div id="info" style="text-align: center; margin-top: 20px; color: #666;"></div>
	</div>

	<script type="module">
		// Simplified treemap algorithm for testing
		const MONDRIAN_COLORS = [
			'#FEFEFE', // White
			'#FFE8E8', // Very light red
			'#E8F0FF', // Very light blue
			'#FFFBE8', // Very light yellow
			'#FFF5F5', // Another light red variant
			'#F0F5FF', // Another light blue variant
		];

		function computeTreemap(items, containerWidth, containerHeight) {
			if (containerWidth <= 0 || containerHeight <= 0) return [];
			if (items.length === 0) return [];

			const validItems = items
				.filter(item => item.value > 0)
				.sort((a, b) => b.value - a.value);

			if (validItems.length === 0) return [];

			const totalValue = validItems.reduce((sum, item) => sum + item.value, 0);
			const containerArea = containerWidth * containerHeight;
			const normalizedItems = validItems.map(item => ({
				...item,
				normalizedValue: (item.value / totalValue) * containerArea
			}));

			const layoutState = {
				x: 0,
				y: 0,
				width: containerWidth,
				height: containerHeight
			};

			const rectangles = [];
			squarify(normalizedItems, [], layoutState, rectangles);

			return applyGap(rectangles, 3);
		}

		function squarify(items, currentRow, container, result) {
			if (items.length === 0) {
				if (currentRow.length > 0) {
					layoutRow(currentRow, container, result);
				}
				return;
			}

			const [nextItem, ...remainingItems] = items;
			const proposedRow = [...currentRow, nextItem];

			if (currentRow.length === 0) {
				squarify(remainingItems, proposedRow, container, result);
			} else {
				const currentWorst = worstAspectRatio(currentRow, container);
				const proposedWorst = worstAspectRatio(proposedRow, container);

				if (proposedWorst <= currentWorst) {
					squarify(remainingItems, proposedRow, container, result);
				} else {
					const newContainer = layoutRow(currentRow, container, result);
					squarify(items, [], newContainer, result);
				}
			}
		}

		function worstAspectRatio(row, container) {
			if (row.length === 0) return Infinity;

			const totalValue = row.reduce((sum, item) => sum + item.normalizedValue, 0);
			const shortEdge = Math.min(container.width, container.height);

			if (shortEdge === 0 || totalValue === 0) return Infinity;

			const rowHeight = totalValue / shortEdge;
			let maxAspectRatio = 0;

			for (const item of row) {
				const rectWidth = item.normalizedValue / rowHeight;
				const aspectRatio = Math.max(rectWidth / rowHeight, rowHeight / rectWidth);
				maxAspectRatio = Math.max(maxAspectRatio, aspectRatio);
			}

			return maxAspectRatio;
		}

		function layoutRow(row, container, result) {
			if (row.length === 0) return container;

			const totalValue = row.reduce((sum, item) => sum + item.normalizedValue, 0);
			const isHorizontal = container.width >= container.height;

			if (isHorizontal) {
				const rowWidth = totalValue / container.height;
				let currentY = container.y;

				for (const item of row) {
					const rectHeight = item.normalizedValue / rowWidth;
					result.push({
						id: item.id,
						x: container.x,
						y: currentY,
						width: rowWidth,
						height: rectHeight,
						value: item.value,
						label: item.label
					});
					currentY += rectHeight;
				}

				return {
					x: container.x + rowWidth,
					y: container.y,
					width: container.width - rowWidth,
					height: container.height
				};
			} else {
				const rowHeight = totalValue / container.width;
				let currentX = container.x;

				for (const item of row) {
					const rectWidth = item.normalizedValue / rowHeight;
					result.push({
						id: item.id,
						x: currentX,
						y: container.y,
						width: rectWidth,
						height: rowHeight,
						value: item.value,
						label: item.label
					});
					currentX += rectWidth;
				}

				return {
					x: container.x,
					y: container.y + rowHeight,
					width: container.width,
					height: container.height - rowHeight
				};
			}
		}

		function applyGap(rectangles, gap) {
			return rectangles.map(rect => ({
				...rect,
				x: rect.x + gap / 2,
				y: rect.y + gap / 2,
				width: Math.max(0, rect.width - gap),
				height: Math.max(0, rect.height - gap)
			}));
		}

		// Test data - sample rooms with device counts
		const testData = [
			{ id: '1', value: 24, label: 'Living Room' },
			{ id: '2', value: 18, label: 'Bedroom' },
			{ id: '3', value: 12, label: 'Kitchen' },
			{ id: '4', value: 8, label: 'Bathroom' },
			{ id: '5', value: 6, label: 'Office' },
			{ id: '6', value: 4, label: 'Garage' }
		];

		// Compute treemap
		const container = document.getElementById('treemap');
		const width = container.clientWidth;
		const height = container.clientHeight;
		const rectangles = computeTreemap(testData, width, height);

		// Render rectangles
		rectangles.forEach((rect, index) => {
			const div = document.createElement('div');
			div.className = 'rect';
			div.style.left = rect.x + 'px';
			div.style.top = rect.y + 'px';
			div.style.width = rect.width + 'px';
			div.style.height = rect.height + 'px';
			div.style.backgroundColor = MONDRIAN_COLORS[index % MONDRIAN_COLORS.length];

			const label = document.createElement('div');
			label.className = 'rect-label';
			label.textContent = rect.label;

			const value = document.createElement('div');
			value.className = 'rect-value';
			value.textContent = `${rect.value} devices`;

			div.appendChild(label);
			div.appendChild(value);
			container.appendChild(div);

			div.addEventListener('click', () => {
				alert(`${rect.label}: ${rect.value} devices`);
			});
		});

		// Display info
		const info = document.getElementById('info');
		info.textContent = `Rendered ${rectangles.length} rooms using squarified treemap algorithm`;
	</script>
</body>
</html>
